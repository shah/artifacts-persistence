import { MutableTextArtifact, DefaultTextArtifact } from "../artifact.ts";
import {
  contextMgr as cm,
  inflect,
  valueMgr as vm,
  serializeJS,
  denoLibPrettier as dlp,
} from "../deps.ts";
import type { PersistenceHandler, PersistArtifactOptions } from "../io.ts";
import type { TextArtifactNature } from "../nature.ts";
import * as code from "../code.ts";

export const typeScriptArtifact = new (class implements TextArtifactNature {
  readonly isTextArtifactNature = true;
  readonly name = "TypeScript";
  readonly defaultFileExtn: string = ".ts";
  readonly fileExtensions: string[] = [this.defaultFileExtn];
  readonly defaultPreamble: vm.TextValue =
    "// Code generated by Netspective IGS. DO NOT EDIT.\n\n";

  constructor() {}
})();

export class TypeScriptArtifact extends DefaultTextArtifact {
  constructor() {
    super({ nature: typeScriptArtifact });
  }
}

export class TypeScriptArtifacts implements code.PolyglotCodeArtifacts {
  readonly modules: TypeScriptModule[] = [];
  readonly autoFormat: boolean;

  constructor(
    readonly ph: PersistenceHandler,
    { autoFormat }: code.PolyglotCodeArtifactsOptions,
  ) {
    this.autoFormat = autoFormat !== undefined ? autoFormat : true;
  }

  declareModule(module: TypeScriptModule): code.PolyglotModuleDecl {
    this.modules.push(module);
    return module;
  }

  emit(
    ctx: cm.Context,
    eh: code.PolyglotErrorHandler,
    options?: PersistArtifactOptions,
  ): void {
    for (const module of this.modules) {
      const unformattedMTA = new TypeScriptArtifact();
      let formattedMTA = unformattedMTA;
      module.emit(ctx, unformattedMTA, eh);
      if (this.autoFormat) {
        formattedMTA = new TypeScriptArtifact();
        formattedMTA.appendText(
          ctx,
          dlp.prettier.format(unformattedMTA.textFragment(ctx), {
            parser: "typescript",
            plugins: dlp.prettierPlugins,
          }),
        );
      }

      this.ph.persistTextArtifact(
        ctx,
        `${inflect.toKebabCase(module.name)}.ts`,
        formattedMTA,
        options,
      );
    }
  }
}

export class TypeScriptModule implements code.PolyglotModuleDecl {
  readonly isPolyglotModuleDecl = true;
  readonly interfaces: TypeScriptInterface[] = [];
  readonly content: TypeScriptContent[] = [];

  constructor(
    readonly code: TypeScriptArtifacts,
    readonly name: inflect.InflectableValue,
  ) {
  }

  declareInterface(intf: TypeScriptInterface): code.PolyglotInterfaceDecl {
    this.interfaces.push(intf);
    return intf;
  }

  declareContent(content: TypeScriptContent): code.PolyglotContentDecl {
    this.content.push(content);
    return content;
  }

  emit(
    ctx: cm.Context,
    mta: MutableTextArtifact,
    eh: code.PolyglotErrorHandler,
  ): void {
    let blockCount = 0;
    for (const intf of this.interfaces) {
      if (blockCount > 0) {
        mta.appendText(ctx, "\n\n");
      }
      intf.emit(ctx, mta, eh);
      blockCount++;
    }

    for (const c of this.content) {
      if (blockCount > 0) {
        mta.appendText(ctx, "\n\n");
      }

      const modifiers = (c.moduleExport ? "export " : "") +
        (c.mutable ? "let" : "const");
      const identifer = inflect.toCamelCase(c.name);
      mta.appendText(
        ctx,
        `${modifiers} ${identifer}: ${c.getTypeScriptTypeIdentifier()} = ${
          serializeJS.stringify(c.content)
        };`,
      );
      if (c.moduleDefault) {
        mta.appendText(ctx, `\n\nexport default ${identifer};\n`);
      }
      blockCount++;
    }
  }
}

export interface TypeScriptInterfaceOptions
  extends code.PolyglotInterfaceDeclOptions {
  readonly emitContentAsConst?: boolean;
  readonly emitContentAsConstIdentifier?: inflect.InflectableValue;
}

export class TypeScriptInterface implements code.PolyglotInterfaceDecl {
  readonly isPolyglotInterfaceDecl: true = true;
  readonly properties: code.PolyglotPropertyDecl[] = [];
  readonly emitContentAsConst: boolean;
  readonly emitContentAsConstIdentifier?: inflect.InflectableValue;

  constructor(
    readonly module: TypeScriptModule,
    readonly name: inflect.InflectableValue,
    { emitContentAsConst, emitContentAsConstIdentifier }:
      TypeScriptInterfaceOptions,
  ) {
    this.emitContentAsConst = emitContentAsConst !== undefined
      ? emitContentAsConst
      : true;
    this.emitContentAsConstIdentifier = emitContentAsConstIdentifier;
  }

  declareProperty(prop: code.PolyglotPropertyDecl): code.PolyglotPropertyDecl {
    this.properties.push(prop);
    return prop;
  }

  emit(
    ctx: cm.Context,
    mta: MutableTextArtifact,
    eh: code.PolyglotErrorHandler,
  ): void {
    const propDecls: string[] = [];
    for (const property of this.properties) {
      const decl = property.getInterfaceDecl(ctx, eh);
      if (decl) {
        propDecls.push(decl);
      }
    }
    const intfIdentifier = inflect.toPascalCase(this.name);
    mta.appendText(ctx, `export interface ${intfIdentifier} {\n`);
    mta.appendText(ctx, "  " + propDecls.join("\n  "));
    mta.appendText(ctx, "\n}");
  }
}

export class TypicalTypeScriptProperty implements code.PolyglotPropertyDecl {
  readonly isPolyglotPropertyDecl = true;

  constructor(
    readonly name: inflect.InflectableValue,
    readonly tsType: TypeScriptInterface | vm.TextValue,
  ) {
  }

  getInterfaceDecl(
    ctx: cm.Context,
    eh: code.PolyglotErrorHandler,
  ): string | undefined {
    return `readonly ${inflect.toCamelCase(this.name)}: ${
      code.isPolyglotInterfaceDecl(this.tsType)
        ? inflect.toPascalCase(this.tsType.name)
        : vm.resolveTextValue(ctx, this.tsType)
    };`;
  }
}

export interface TypeScriptContentOptions extends code.PolyglotContentOptions {
  readonly moduleExport?: boolean;
  readonly moduleDefault?: boolean;
}

export class TypeScriptContent
  implements code.PolyglotContentDecl, TypeScriptContentOptions {
  readonly isPolyglotContentDecl = true;
  readonly mutable?: boolean;
  readonly moduleExport?: boolean;
  readonly moduleDefault?: boolean;

  constructor(
    readonly name: inflect.InflectableValue,
    readonly tsType: TypicalTypeScriptProperty | TypeScriptInterface,
    readonly content: unknown,
    { mutable, moduleDefault, moduleExport }: TypeScriptContentOptions,
  ) {
    this.mutable = mutable;
    this.moduleExport = moduleExport;
    this.moduleDefault = moduleDefault;
  }

  getTypeScriptTypeIdentifier(): string {
    if (code.isPolyglotInterfaceDecl(this.tsType)) {
      const arraySuffix = this.content
        ? (Array.isArray(this.content) ? "[]" : "")
        : "";
      return inflect.toPascalCase(this.tsType.name) + arraySuffix;
    }

    if (code.isPolyglotPropertyDecl(this.tsType)) {
      return inflect.toPascalCase(this.tsType.name);
    }

    return `[TypeScriptContent] unknown tsType: ${this.tsType}`;
  }
}
